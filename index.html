<!DOCTYPE html>
<html>
    <head>
        <title>KT 융합기술원</title>
        <meta name="author" content="Sean Bradley" />
        <link rel="stylesheet" href="/stylesheets/style.css" />
        <style>
            body {
                overflow: hidden;
                margin: 0px;
            }

            a {
                color: #ffffff;
            }

            #progressBar {
                width: 500px;
                height: 24px;
                position: absolute;
                left: 50%;
                top: 25px;
                margin-left: -250px;
            }

            #instructions {
                color: white;
                position: absolute;
                left: 50%;
                top: 10px;
                margin-left: -120px;
                font-family: monospace;
            }
        </style>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3..1/jquery.min.js"></script>        
    </head>

    <body>
        <progress value="0" max="100" id="progressBar"></progress>
        <video id = 'video1' playsinLine webkit-playsinLine 
        width="1290" height="760" src = "./asset/meta.mp4" style="display: none"
        ></video>

        <video id = 'video2' playsinLine webkit-playsinLine 
        width="1290" height="760" src = "./asset/dxsummit.mp4" style="display: none"
        ></video>

        <script type="module">
            import * as THREE from 'https://cdn.skypack.dev/three@0.135.0/build/three.module.js'
            import { OrbitControls } from 'https://cdn.skypack.dev/three@0.135.0/examples/jsm/controls/OrbitControls.js'
            import { FBXLoader } from 'https://cdn.skypack.dev/three@0.135.0/examples/jsm/loaders/FBXLoader.js'
 
            const scene = new THREE.Scene()
            //scene.background = new THREE.Color( 0xccFFFF );
            //scene.add(new THREE.AxesHelper(5))
/*
            const light = new THREE.PointLight()
            light.position.set(10.8, 1.4, 1.0)
            scene.add(light)
*/
            const directionalLight = new THREE.DirectionalLight( 0x111111, 0.1 );
            scene.add( directionalLight );

            const ambientLight = new THREE.AmbientLight( 0xffffff, 0.2 )
            scene.add(ambientLight)

            //Background Textures
            const bgloader = new THREE.CubeTextureLoader();
            bgloader.setPath( 'asset/bg/' );

            //let textureCube = bgloader.load( [ 'posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg' ] );
            let textureCube = bgloader.load( [ 'posx.png', 'negx.png', 'posy.png', 'negy.png', 'posz.png', 'negz.png' ] );
            textureCube.encoding = THREE.sRGBEncoding;
            scene.background = textureCube;

            //ground
            var ground_texture, ground_material, ground_plane;
            ground_texture = THREE.ImageUtils.loadTexture( "./asset/bg/negy.png" );
            // assuming you want the texture to repeat in both directions:
            ground_texture.wrapS = THREE.RepeatWrapping; 
            ground_texture.wrapT = THREE.RepeatWrapping;
            // how many times to repeat in each direction; the default is (1,1),
            //   which is probably why your example wasn't working
            ground_texture.repeat.set( 4, 4 ); 
            ground_material = new THREE.MeshLambertMaterial({ map : ground_texture });
            ground_plane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), ground_material);
            ground_plane.material.side = THREE.DoubleSide;
            //ground_plane.position.x = 100;

            // rotation.z is rotation around the z-axis, measured in radians (rather than degrees)
            // Math.PI = 180 degrees, Math.PI / 2 = 90 degrees, etc.
            ground_plane.rotation.set(Math.PI / 2,0,0);
            scene.add(ground_plane);          
            

            const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000)
            camera.position.set(15, 7.5, -7.5)

            const renderer = new THREE.WebGLRenderer()
            renderer.setSize(window.innerWidth, window.innerHeight)
            document.body.appendChild(renderer.domElement)

            const controls = new OrbitControls(camera, renderer.domElement)
            controls.enableDamping = true
            controls.minPolarAngle = 0.5;
            controls.maxPolarAngle = 1.5;
            controls.target.set(0, 0, 0)

            const material = new THREE.MeshNormalMaterial()

            // PICKING ------------------------------------------
            //BoxGeometry (makes a geometry)
            const boxgeometry = new THREE.BoxGeometry( 0.5,0.5,0.5);
            //Material to apply to the cube (green)
            const boxmaterial = new THREE.MeshBasicMaterial( { color: 0xff5556 } );
            //Applies material to BoxGeometry
            const cube1 = new THREE.Mesh( boxgeometry, boxmaterial );
            cube1.position.set(2.5,2.2,-1);
            cube1.rotation.set(Math.PI / 4,Math.PI / 4,0);
            cube1.name = "cube1";
            //Adds cube to the scene
            scene.add( cube1 );
            const cube2 = new THREE.Mesh( boxgeometry, boxmaterial );
            cube2.position.set(2.5,2.2,1);
            cube2.rotation.set(Math.PI / 4,Math.PI / 4,0);
            //Adds cube to the scene
            cube2.name = "cube2";
            scene.add( cube2 );
            
            // VIDEO ------------------------------------------
            let video1 = document.getElementById("video1");
            let videoTexture1 = new THREE.VideoTexture(video1);
            videoTexture1.minFilter = THREE.LinearFilter;
            videoTexture1.magFilter = THREE.LinearFilter;

            var movieMaterial1 = new THREE.MeshBasicMaterial({
                map : videoTexture1,
                side : THREE.FrontSide,
                toneMapped : false,
            });

            let movieGeometry1 = new THREE.PlaneGeometry(5,3.7);
            let movieCubeScreen1 = new THREE.Mesh(movieGeometry1, movieMaterial1);
            movieCubeScreen1.rotation.set(0,2.05,0);
            movieCubeScreen1.position.set(-13.5,2.5,6.9);
            
            scene.add(movieCubeScreen1);

            let video2 = document.getElementById("video2");
            let videoTexture2 = new THREE.VideoTexture(video2);
            videoTexture2.minFilter = THREE.LinearFilter;
            videoTexture2.magFilter = THREE.LinearFilter;

            var movieMaterial2 = new THREE.MeshBasicMaterial({
                map : videoTexture2,
                side : THREE.FrontSide,
                toneMapped : false,
            });

            let movieGeometry2 = new THREE.PlaneGeometry(5,3.7);
            let movieCubeScreen2 = new THREE.Mesh(movieGeometry2, movieMaterial2);
            movieCubeScreen2.rotation.set(0,0.85,0);
            movieCubeScreen2.position.set(-16,2.5,-7);
            scene.add(movieCubeScreen2);





            const fbxLoader = new FBXLoader()
            fbxLoader.load(
                'asset/rndcenter.fbx',
                (object) => {
                     object.scale.set(0.01, 0.01, 0.01)
                    scene.add(object)
                    progressBar.style.display = 'none'
                },
                (xhr) => {
                    if (xhr.lengthComputable) {
                        var percentComplete = (xhr.loaded / xhr.total) * 100
                        progressBar.value = percentComplete
                        progressBar.style.display = 'block'
                    }
                },
                (error) => {
                    console.log(error)
                }
            )

            window.addEventListener('resize', onWindowResize, false)
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight
                camera.updateProjectionMatrix()
                renderer.setSize(window.innerWidth, window.innerHeight)
                render()
            }

            // PICKING
            window.addEventListener('click', onPkCheck, false)
            function onPkCheck() {
                 var mouseVector = new THREE.Vector3();
                var raycaster = new THREE.Raycaster();
                mouseVector.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
                mouseVector.unproject(camera);
                raycaster.set(camera.position, mouseVector.sub(camera.position).normalize());

                var interTarget = [];
                interTarget.push(cube1);
                interTarget.push(cube2);
                var intersects = raycaster.intersectObjects(interTarget, true);
                if (intersects.length > 0) {
                    console.log(intersects[0]);
                    if(intersects[0].object.name=='cube1')
                        window.location = "town.html";
                    else if(intersects[0].object.name=='cube2')
                        window.location = "cafe.html";
                }                
            }

            function animate() {
                videoTexture1.needsUpdate = true;
                videoTexture2.needsUpdate = true;
                requestAnimationFrame(animate)
                controls.update()
                render()
            }

            function render() {
                renderer.render(scene, camera)
            }
            animate()

            // KEY EVENT
            document.onkeydown = function(e) {
                if (e.keyCode === 49) { video1.play(); } 
                else if (e.keyCode === 50) { video2.play(); } 
                else if (e.keyCode === 32) {
                    //space
                    video1.pause();
                    video2.pause();
                } else if (e.keyCode === 83) {
                    //s
                    video1.stop();
                    video2.stop();
                } else if (e.keyCode === 82) {
                    //r
                    video1.currentTime = 0;
                    video2.currentTime = 0;
                }
            }
        </script>
    </body>
</html>